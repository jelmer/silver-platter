#!/usr/bin/python3
# Copyright (C) 2019 Jelmer Vernooij <jelmer@jelmer.uk>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

"""Support for integration multi-arch hints."""

import argparse
import logging

import silver_platter  # noqa: F401

from lintian_brush import run_lintian_fixer, SUPPORTED_CERTAINTIES
from lintian_brush.config import Config
from debmutate.reformatting import GeneratedFile, FormattingUnpreservable

from silver_platter.debian import control_files_in_root, control_file_present, is_debcargo_package

from breezy.workingtree import WorkingTree

BRANCH_NAME = "multi-arch-fixes"


async def main():
    import argparse

    parser = argparse.ArgumentParser()
    # Hide the minimum-certainty option for the moment.
    parser.add_argument(
        "--minimum-certainty",
        type=str,
        choices=SUPPORTED_CERTAINTIES,
        default=None,
        help=argparse.SUPPRESS,
    )
    parser.add_argument(
        "--allow-reformatting",
        default=None,
        action="store_true",
        help=argparse.SUPPRESS,
    )
    args = parser.parse_args()

    local_tree, subpath = WorkingTree.open_containing('.')

    from lintian_brush.multiarch_hints import (
        cache_download_multiarch_hints,
        multiarch_hints_by_binary,
        parse_multiarch_hints,
    )

    with cache_download_multiarch_hints() as f:
        hints = multiarch_hints_by_binary(parse_multiarch_hints(f))

    from lintian_brush import NoChanges
    from lintian_brush.multiarch_hints import (
        MultiArchHintFixer,
    )

    base_revid = local_tree.last_revision()
    minimum_certainty = args.minimum_certainty
    allow_reformatting = args.allow_reformatting
    try:
        cfg = Config.from_workingtree(local_tree, subpath)
    except FileNotFoundError:
        pass
    else:
        if minimum_certainty is None:
            minimum_certainty = cfg.minimum_certainty()
        if allow_reformatting is None:
            allow_reformatting = cfg.allow_reformatting()
        if update_changelog is None:
            update_changelog = cfg.update_changelog()

    if control_files_in_root(local_tree, subpath):
        raise ChangerError(
            "control-files-in-root",
            "control files live in root rather than debian/ " "(LarstIQ mode)",
        )

    if is_debcargo_package(local_tree, subpath):
        raise ChangerError("nothing-to-do", "Package uses debcargo")
    elif not control_file_present(local_tree, subpath):
        raise ChangerError("missing-control-file", "Unable to find debian/control")

    try:
        with local_tree.lock_write():
            result, summary = run_lintian_fixer(
                local_tree,
                MultiArchHintFixer(hints),
                update_changelog=update_changelog,
                minimum_certainty=minimum_certainty,
                subpath=subpath,
                allow_reformatting=allow_reformatting,
                net_access=True,
                committer=committer,
                changes_by="apply-multiarch-hints",
            )
    except NoChanges:
        raise ChangerError("nothing-to-do", "no hints to apply")
    except FormattingUnpreservable as e:
        raise ChangerError(
            "formatting-unpreservable",
            "unable to preserve formatting while editing %s" % e.path,
        )
    except GeneratedFile as e:
        raise ChangerError(
            "generated-file", "unable to edit generated file: %r" % e
        )

    applied_hints = []
    hint_names = []
    for (binary, hint, description, certainty) in result.changes:
        hint_names.append(hint["link"].split("#")[-1])
        entry = dict(hint.items())
        hint_names.append(entry["link"].split("#")[-1])
        entry["action"] = description
        entry["certainty"] = certainty
        applied_hints.append(entry)
        logging.info("%s: %s" % (binary["Package"], description))

    reporter.report_metadata("applied-hints", applied_hints)

    branches = [("main", None, base_revid, local_tree.last_revision())]

    tags = []

    return ChangerResult(
        description="Applied multi-arch hints.",
        mutator=result,
        branches=branches,
        tags=tags,
        value=calculate_value(hint_names),
        sufficient_for_proposal=True,
        proposed_commit_message="Apply multi-arch hints.",
    )

if __name__ == "__main__":
    import asyncio
    import sys

    sys.exit(asyncio.run(main()))
